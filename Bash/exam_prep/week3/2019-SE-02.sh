#  Напишете шел скрипт, който приема множество параметри. Общ вид на извикване:
# ./foo.sh [-n N] FILE1...

# В общия случай параметрите се третират като имена на (.log) файлове, които
# трябва да бъдат обработени от скрипта, със следното изключение: ако първият
# параметър е стрингът -n, то вторият параметър е число, дефиниращо стойност
# на променливата N, която ще ползваме в скрипта. Въвеждаме понятието идентификатор
# на файл (ИДФ), което се състои от името на даден файл без разширението
# .log. За удобство приемаме, че скриптът:

# • ще бъде извикван с аргументи имена на файлове, винаги завършващи на .log
# • няма да бъде извикван с аргументи имена на файлове с еднакъв ИДФ.

# Лог файловете са текстови, като всеки ред има следния формат:
# • време: timestamp във формат YYYY-MM-DD HH:MM:SS
# • интервал
# • данни: поредица от символи с произволна дължина

# За удобство приемаме, че редовете във всеки файл са сортирани по време възходящо.
# Примерно съдържание на даден лог файл:
# 2019-05-05 06:26:54 orthanc rsyslogd: rsyslogd was HUPed
# 2019-05-06 06:30:32 orthanc rsyslogd: rsyslogd was HUPed
# 2019-05-06 10:48:29 orthanc kernel: [1725379.728871] Chrome_~dThread[876]: segfault

# Скриптът трябва да извежда на STDOUT последните N реда (ако N не е дефинирано - 10 реда) от всеки
# файл, в следния формат:
# • timestamp във формат YYYY-MM-DD HH:MM:SS
# • интервал
# • ИДФ
# • интервал
# • данни
# Изходът трябва да бъде глобално сортиран по време възходящо


#!/bin/bash

if [[ $# -lt 1 ]]; then
    echo "Expected at least one arg"
    exit 1
fi

N=10

if [[ "${1}" == '-n' ]]; then
    shift
    N=$(echo "${1}" | grep -E "^[1-9]+[0-9]*$")
    if [[ $? -ne 0 ]]; then
        echo "Invalid -n param: expected number"
        exit 2
    fi

    shift

fi

result=$(mktemp)

for file in "${@}"; do
    if [[ ! -f "${file}" ]]; then
        echo "Invalid arg: ${file}"
        continue
    fi

    idf=$(basename "${file}" .log)

    while read line; do

        timestamp=$(echo "${line}" | awk ' { print $1 " " $2 } ')
        data=$(echo "${line}" | awk ' { for(i=3;i<NF;i++) printf "%s ", $i; }')
        printf "%s %s %s\n" "$timestamp" "$idf" "$data" >> ${result}
    done < <(cat "${file}" | tail -n "${N}")

done

cat "${result}" | sort
